# Lab2 实验报告

###### 201240069 曹语桐  201240060 林彦葶

 

## 一、如何编译运行程序

在Code 目录下执行：

```
make clean  //清理之前编译链接生成的文件
make 
```

生成可执行文件parser。

对测试文件../Test/test.c，运行./parser ../Test/test.c就可以得到输出结果。

PS：我们设置了简洁打印模式与详细打印模式，在main.c中令sim=0则输出详细词法信息，令bisonsim=0则输出详细语法信息，令errorsim=0则输出详细错误恢复信息，将这些变量置为1则输出信息是实验要求的标准输出。

 

## 二、实现的主要功能

##### 我们实现了讲义上所要求的全部必做和选做内容：查出C--测试文件中的语义错误并输出错误类型和对应行数。

1. 代码结构

构造完语法树后，对每一个中间节点构造函数计算其属性，大致结构如下

```
L_dfvisit(n){
	for m = 从左到右n的每个子节点 do{
		计算m的继承属性;
		L_dfvisit(m);
	}
	计算n的综合属性;
}
```

遇到语法单元ExtDef或Def时，说明该结点的子节点包含了变量或函数的定义信息。

Specifier，StructSpecifier对应的函数需返回其对应节点的类型描述信息，封装在结构体`Type`中。

OptTag，Tag对应函数需返回对应节点的符号名。

Def,DefList,DecList,Dec,VarDec,VarList,ParamDec,Args需返回其域链表，链表里包含了该节点中以嵌套方式指明了其中每一级的数据结构的所有信息。共有基本类型，数组，结构体，函数四种底层类型，其中基本类型应指明是INT或FLOAT；数组类型应指明维度数和每一个维度数组大小(通过嵌套实现)；结构体类型应通过一个FieldList链表串联所有成员，以描述其每一个成员的姓名和类型信息；函数类型应描述其形参个数，在目前所在位置有无定义过，返回值类型和每一个形参的名字和类型。



2. 支持多层作用域的符号表的实现

我们采用Imperative Style的维护风格，利用十字链表和open hashing散列表实现支持多层作用域的符号表。hash进同一个槽的变量用链表串起来，所有处于同一层作用域的变量用另一个维度的链表串起来。

将符号插入符号表共有三个时机：定义了结构体及其名字时，定义了函数时，定义了变量时。每次插入前都要先检查一下同样的符号名的其作用域内有无其他类型相同的语法结构定义过，若定义过，则报语义错误。

为支持多层作用域，我们用一个数组形式的栈记录一个作用域对应的链表的首节点指针，按照找到节点的顺序将当前作用域中的符号挂到对应的链表上。每次离开一块作用域就顺着此作用域对应的链表将所有同层变量删去。新增链表的时机如下：

1.每次发现一个新的函数时，将函数形参和语句块内出现的符号挂到当前作用域对应的链表上。

2.进入结构体定义语句块前

3.遇到if/while时



3. 语义错误的检测

   要求检测的语义错误大致可以归为以下两类：

   1. 某单元重复定义/访问未定义的单元：类型号1、2、3、4、14、15、16、17、18。可通过检查作用域内有无同名符号实现。
   2. 类型不匹配：类型号5、6、7、8、9、10、11、12、13、19。通过在添加属性过程中进行类型比较实现。类型比较在函数`CompareType()`中实现，此函数可以比较两个类型为BASIC/ARRAY/STRUCTURE的Type结构描述信息是否一致。

   注意：

   - 有几个结构体内特有的错误类型，但单凭我们定义的数据结构不足以描述当前是否在结构体内，因此有几个语法单元对应的函数增加形参stru描述当前是否在结构体定义里

   - 为了区分结构体类型的名字和结构体变量的名字，我们后来又新加了一个类型STRUCT_NAME来表示结构体类型名

   - lab2增加了函数的声明相关要求，因此在描述函数的数据结构中加入表明当前函数是否已定义过

     